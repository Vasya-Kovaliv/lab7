import random
import math
import hashlib


def generate_prime_number(length):
    # Згенерувати випадкове просте число заданої довжини
    while True:
        p = random.getrandbits(length)
        if is_prime(p):
            return p


def is_prime(n, k=5):
    # Перевірити, чи є число простим за допомогою тесту Міллера-Рабіна
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    r, s = 0, n - 1
    while s % 2 == 0:
        r += 1
        s //= 2
    for _ in range(k):
        a = random.randrange(2, n - 1)
        x = pow(a, s, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False
    return True


def find_primitive_root(p):
    # Знайти примітивний корінь модуля p
    if p == 2:
        return 1
    p1 = 2
    p2 = (p - 1) // p1
    while True:
        g = random.randint(2, p - 1)
        if not (pow(g, p2, p) == 1):
            if not pow(g, p1, p) == 1:
                return g


def mod_inverse(a, m):
    # Знаходження оберненого елемента до a за модулем m
    if a == 0:
        raise ValueError("Обернений елемент не існує.")
    if m == 1:
        return 0
    g, x, _ = extended_gcd(a, m)
    if g != 1:
        raise ValueError("Обернений елемент не існує.")
    return x % m


def extended_gcd(a, b):
    # Знаходження найбільного спільного дільника та оберненого елемента за модулем (розширений алгоритм Евкліда)
    x, y, u, v = 0, 1, 1, 0
    while a != 0:
        q, r = b // a, b % a
        m, n = x - u * q, y - v * q
        b, a, x, y, u, v = a, r, u, v, m, n
    gcd = b
    return gcd, x, y


def generate_keys(p, g):
    # Генерація ключів
    a = random.randint(1, p - 1)
    b = pow(g, a, p)
    return a, b


def sign_message(p, g, a, message):
    # Підпис повідомлення
    h = int.from_bytes(hashlib.sha256(message.encode()).digest(), 'big')
    while True:
        k = random.randint(1, p - 1)
        if math.gcd(k, p - 1) == 1:
            break
    r = pow(g, k, p) % (p - 1)
    s = ((h - a * r) * mod_inverse(k, p - 1)) % (p - 1)
    return r, s


def verify_signature(p, g, b, message, r, s):
    # Перевірка підпису
    h = int.from_bytes(hashlib.sha256(message.encode()).digest(), 'big')
    u1 = (h * mod_inverse(s, p - 1)) % (p - 1)
    u2 = (r * mod_inverse(s, p - 1)) % (p - 1)
    v1 = pow(g, u1, p)
    v2 = pow(b, u2, p)
    v = ((v1 * v2) % p) % (p - 1)
    return v == r


def test_signature_verification():
    message = "Hello, World!"
    p = generate_prime_number(2048)
    g = find_primitive_root(p)
    a, b = generate_keys(p, g)
    r, s = sign_message(p, g, a, message)
    print("Повідомлення:", message)
    print("Публічний ключ:", b)
    print("Перевірка підпису:", verify_signature(p, g, b, message, r, s))

test_signature_verification()
